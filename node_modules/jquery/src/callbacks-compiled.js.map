{"version":3,"sources":["callbacks.js"],"names":[],"mappings":";;AAAA,MAAM,CAAE,CACP,QAAQ,EACR,iBAAiB,CACjB,EAAE,UAAU,MAAM,EAAE,SAAS,EAAG;;;AAGjC,UAAS,aAAa,CAAE,OAAO,EAAG;AACjC,MAAI,MAAM,GAAG,EAAE,CAAC;AAChB,QAAM,CAAC,IAAI,CAAE,OAAO,CAAC,KAAK,CAAE,SAAS,CAAE,IAAI,EAAE,EAAE,UAAU,CAAC,EAAE,IAAI,EAAG;AAClE,SAAM,CAAE,IAAI,CAAE,GAAG,IAAI,CAAC;GACtB,CAAE,CAAC;AACJ,SAAO,MAAM,CAAC;EACd;;;;;;;;;;;;;;;;;;;;;;;;AAwBD,OAAM,CAAC,SAAS,GAAG,UAAU,OAAO,EAAG;;;;AAItC,SAAO,GAAG,OAAO,OAAO,KAAK,QAAQ,GACpC,aAAa,CAAE,OAAO,CAAE,GACxB,MAAM,CAAC,MAAM,CAAE,EAAE,EAAE,OAAO,CAAE,CAAC;;AAE9B;AACC,QAAM;;;;AAGN,QAAM;;;;AAGN,QAAK;;;;AAGL,SAAM;;;;AAGN,MAAI,GAAG,EAAE;;;;AAGT,OAAK,GAAG,EAAE;;;;AAGV,aAAW,GAAG,CAAC,CAAC;;;;AAGhB,MAAI,GAAG,SAAP,IAAI,GAAc;;;AAGjB,UAAM,GAAG,OAAO,CAAC,IAAI,CAAC;;;;AAItB,SAAK,GAAG,MAAM,GAAG,IAAI,CAAC;AACtB,UAAQ,KAAK,CAAC,MAAM,EAAE,WAAW,GAAG,CAAC,CAAC,EAAG;AACxC,UAAM,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;AACvB,WAAQ,EAAE,WAAW,GAAG,IAAI,CAAC,MAAM,EAAG;;;AAGrC,SAAK,IAAI,CAAE,WAAW,CAAE,CAAC,KAAK,CAAE,MAAM,CAAE,CAAC,CAAE,EAAE,MAAM,CAAE,CAAC,CAAE,CAAE,KAAK,KAAK,IACnE,OAAO,CAAC,WAAW,EAAG;;;AAGtB,iBAAW,GAAG,IAAI,CAAC,MAAM,CAAC;AAC1B,YAAM,GAAG,KAAK,CAAC;MACf;KACD;IACD;;;AAGD,OAAK,CAAC,OAAO,CAAC,MAAM,EAAG;AACtB,UAAM,GAAG,KAAK,CAAC;IACf;;AAED,SAAM,GAAG,KAAK,CAAC;;;AAGf,OAAK,OAAM,EAAG;;;AAGb,QAAK,MAAM,EAAG;AACb,SAAI,GAAG,EAAE,CAAC;;;KAGV,MAAM;AACN,UAAI,GAAG,EAAE,CAAC;MACV;IACD;GACD;;;;AAGD,MAAI,GAAG;;;AAGN,MAAG,EAAE,eAAW;AACf,QAAK,IAAI,EAAG;;;AAGX,SAAK,MAAM,IAAI,CAAC,MAAM,EAAG;AACxB,iBAAW,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;AAC9B,WAAK,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC;MACrB;;AAED,MAAE,SAAS,GAAG,CAAE,IAAI,EAAG;AACtB,YAAM,CAAC,IAAI,CAAE,IAAI,EAAE,UAAU,CAAC,EAAE,GAAG,EAAG;AACrC,WAAK,MAAM,CAAC,UAAU,CAAE,GAAG,CAAE,EAAG;AAC/B,YAAK,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG,CAAE,GAAG,CAAE,EAAG;AAC1C,aAAI,CAAC,IAAI,CAAE,GAAG,CAAE,CAAC;SACjB;QACD,MAAM,IAAK,GAAG,IAAI,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAE,GAAG,CAAE,KAAK,QAAQ,EAAG;;;AAGlE,WAAG,CAAE,GAAG,CAAE,CAAC;QACX;OACD,CAAE,CAAC;MACJ,CAAA,CAAI,SAAS,CAAE,CAAC;;AAEjB,SAAK,MAAM,IAAI,CAAC,MAAM,EAAG;AACxB,UAAI,EAAE,CAAC;MACP;KACD;AACD,WAAO,IAAI,CAAC;IACZ;;;AAGD,SAAM,EAAE,kBAAW;AAClB,UAAM,CAAC,IAAI,CAAE,SAAS,EAAE,UAAU,CAAC,EAAE,GAAG,EAAG;AAC1C,SAAI,KAAK,CAAC;AACV,YAAQ,CAAE,KAAK,GAAG,MAAM,CAAC,OAAO,CAAE,GAAG,EAAE,IAAI,EAAE,KAAK,CAAE,CAAA,GAAK,CAAC,CAAC,EAAG;AAC7D,UAAI,CAAC,MAAM,CAAE,KAAK,EAAE,CAAC,CAAE,CAAC;;;AAGxB,UAAK,KAAK,IAAI,WAAW,EAAG;AAC3B,kBAAW,EAAE,CAAC;OACd;MACD;KACD,CAAE,CAAC;AACJ,WAAO,IAAI,CAAC;IACZ;;;;AAID,MAAG,EAAE,aAAU,EAAE,EAAG;AACnB,WAAO,EAAE,GACR,MAAM,CAAC,OAAO,CAAE,EAAE,EAAE,IAAI,CAAE,GAAG,CAAC,CAAC,GAC/B,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;IACjB;;;AAGD,QAAK,EAAE,iBAAW;AACjB,QAAK,IAAI,EAAG;AACX,SAAI,GAAG,EAAE,CAAC;KACV;AACD,WAAO,IAAI,CAAC;IACZ;;;;;AAKD,UAAO,EAAE,mBAAW;AACnB,WAAM,GAAG,KAAK,GAAG,EAAE,CAAC;AACpB,QAAI,GAAG,MAAM,GAAG,EAAE,CAAC;AACnB,WAAO,IAAI,CAAC;IACZ;AACD,WAAQ,EAAE,oBAAW;AACpB,WAAO,CAAC,IAAI,CAAC;IACb;;;;;AAKD,OAAI,EAAE,gBAAW;AAChB,WAAM,GAAG,KAAK,GAAG,EAAE,CAAC;AACpB,QAAK,CAAC,MAAM,EAAG;AACd,SAAI,GAAG,MAAM,GAAG,EAAE,CAAC;KACnB;AACD,WAAO,IAAI,CAAC;IACZ;AACD,SAAM,EAAE,kBAAW;AAClB,WAAO,CAAC,CAAC,OAAM,CAAC;IAChB;;;AAGD,WAAQ,EAAE,kBAAU,OAAO,EAAE,IAAI,EAAG;AACnC,QAAK,CAAC,OAAM,EAAG;AACd,SAAI,GAAG,IAAI,IAAI,EAAE,CAAC;AAClB,SAAI,GAAG,CAAE,OAAO,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAE,CAAC;AACrD,UAAK,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;AACnB,SAAK,CAAC,MAAM,EAAG;AACd,UAAI,EAAE,CAAC;MACP;KACD;AACD,WAAO,IAAI,CAAC;IACZ;;;AAGD,OAAI,EAAE,gBAAW;AAChB,QAAI,CAAC,QAAQ,CAAE,IAAI,EAAE,SAAS,CAAE,CAAC;AACjC,WAAO,IAAI,CAAC;IACZ;;;AAGD,QAAK,EAAE,iBAAW;AACjB,WAAO,CAAC,CAAC,MAAK,CAAC;IACf;GACD,CAAC;;AAEH,SAAO,IAAI,CAAC;EACZ,CAAC;;AAEF,QAAO,MAAM,CAAC;CACb,CAAE,CAAC","file":"callbacks-compiled.js","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/rnotwhite\"\n], function( jQuery, rnotwhite ) {\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\nreturn jQuery;\n} );\n"]}